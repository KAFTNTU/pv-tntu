<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>БіБіп 3D: Еволюція</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Share+Tech+Mono&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* Fallback dark */
            font-family: 'Share Tech Mono', monospace;
            color: #fff;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-panel {
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        h1 {
            font-family: 'Russo One', sans-serif;
            margin: 0;
            font-size: 32px;
            color: #ff0055;
            text-shadow: 0 0 10px rgba(255, 0, 85, 0.5);
            font-style: italic;
        }

        .phase-badge {
            background: rgba(0, 255, 242, 0.1);
            border: 1px solid #00fff2;
            padding: 5px 15px;
            border-radius: 20px;
            color: #00fff2;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-msg {
            font-size: 18px;
            color: #ddd;
            text-shadow: 1px 1px 2px black;
        }

        .bottom-panel {
            padding: 30px;
            text-align: center;
            pointer-events: auto;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, transparent 100%);
        }

        button.action-btn {
            background: #ff0055;
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Russo One', sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.4);
            transition: transform 0.2s;
        }

        button.action-btn:hover { transform: scale(1.05); }
        button.action-btn:disabled { background: #444; cursor: not-allowed; filter: grayscale(1); }

        #toast-container {
            position: absolute; top: 20%; left: 50%;
            transform: translate(-50%, -50%);
            display: flex; flex-direction: column; gap: 10px;
            align-items: center;
        }

        .toast {
            background: rgba(20, 20, 20, 0.95);
            border-left: 4px solid #00fff2;
            padding: 15px 25px;
            color: white;
            border-radius: 4px;
            font-size: 16px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #cursor-tooltip {
            position: absolute;
            background: rgba(10, 10, 20, 0.9);
            border: 1px solid #00fff2;
            color: #00fff2;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 1000;
        }

        .controls-hint {
            position: absolute; bottom: 20px; left: 20px;
            color: #888; font-size: 12px; text-align: left;
        }
    </style>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="cursor-tooltip"></div>

    <div id="ui-layer">
        <div class="top-panel">
            <div>
                <h1>БіБіп <span style="font-size:0.5em; vertical-align: super; color:#fff;">EVO</span></h1>
                <div class="phase-badge" id="phase-badge">Завантаження...</div>
            </div>
            <div class="status-msg" id="status-msg">Ініціалізація...</div>
        </div>

        <div id="toast-container"></div>

        <div class="controls-hint">
            ЛКМ: Тягнути деталь<br>
            ПКМ: Огляд<br>
            Колесо: Зум
        </div>

        <div class="bottom-panel">
            <button id="next-btn" class="action-btn" onclick="Game.nextPhase()" disabled>ДАЛІ &rarr;</button>
        </div>
    </div>

<script>
/**
 * BIBIP EVO ENGINE - STABLE BUILD
 */

// Internal Minimal Tween to avoid external dependency issues
const TWEEN = {
    tweens: [],
    update(time) {
        this.tweens = this.tweens.filter(t => t.update(time || Date.now()));
        return true;
    },
    Easing: {
        Quadratic: { Out: k => k * (2 - k) },
        Back: { Out: k => --k * k * ((1.70158 + 1) * k + 1.70158) + 1 },
        Bounce: { Out: k => {
            if (k < (1 / 2.75)) return 7.5625 * k * k;
            else if (k < (2 / 2.75)) return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
            else if (k < (2.5 / 2.75)) return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
            else return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }}
    },
    Tween: class {
        constructor(obj) { this.obj = obj; this.props = {}; this.startState = {}; this._yoyo = false; }
        to(props, duration) { this.props = props; this.duration = duration; return this; }
        easing(fn) { this.ease = fn || (k => k); return this; }
        yoyo(bool) { this._yoyo = bool; return this; }
        repeat(count) { this.repeats = count; return this; }
        start() {
            this.startTime = Date.now();
            for(let k in this.props) this.startState[k] = this.obj[k];
            TWEEN.tweens.push(this);
            return this;
        }
        update(time) {
            let elapsed = (time - this.startTime) / this.duration;
            if (elapsed > 1) {
                if (this._yoyo) {
                    // Simple yoyo logic for this mini-engine
                    // Swap start/end
                    let temp = {};
                    for(let k in this.props) {
                         temp[k] = this.startState[k];
                         this.startState[k] = this.props[k];
                         this.props[k] = temp[k];
                    }
                    this.startTime = time;
                    elapsed = 0;
                } else {
                    elapsed = 1;
                }
            }
            const val = this.ease ? this.ease(elapsed) : elapsed;
            for(let k in this.props) {
                this.obj[k] = this.startState[k] + (this.props[k] - this.startState[k]) * val;
            }
            return elapsed < 1 || this._yoyo;
        }
    }
};

const CONFIG = {
    colors: {
        chassisMain: 0xD32F2F,
        chassisSec: 0x212121,
        wheelTire: 0x1a1a1a,
        wheelRim: 0xeeeeee,
        motor: 0x607D8B,
        copper: 0xB87333,
        gear: 0xFFFFFF,
        washer: 0xFFD700,
        battery: 0x2E7D32,
        sensor: 0x00B0FF,
        controller: 0x00695C,
        wire: 0xFFC107,
        highlight: 0x00FFF2,
        valid: 0x00E676,
        invalid: 0xFF5252
    },
    phases: { MECH: 0, ELEC: 1, POWER: 2, TEST: 3 }
};

// Part Factory
const PartFactory = {
    wheel: () => {
        const g = new THREE.Group();
        const tire = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.8, 16), new THREE.MeshStandardMaterial({ color: CONFIG.colors.wheelTire, roughness: 0.9 }));
        tire.rotation.z = Math.PI/2; tire.castShadow = true; g.add(tire);
        const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.85, 8), new THREE.MeshStandardMaterial({ color: CONFIG.colors.wheelRim, metalness: 0.8 }));
        rim.rotation.z = Math.PI/2; g.add(rim);
        const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.9, 6), new THREE.MeshStandardMaterial({color: 0x333}));
        hub.rotation.z = Math.PI/2; g.add(hub);
        return g;
    },
    motor: () => {
        const g = new THREE.Group();
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshStandardMaterial({ color: CONFIG.colors.motor, metalness: 0.4 })));
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8), new THREE.MeshStandardMaterial({ color: 0x888 }));
        shaft.rotation.x = Math.PI/2; shaft.position.z = 0.5; g.add(shaft);
        const copper = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1.1), new THREE.MeshStandardMaterial({ color: CONFIG.colors.copper }));
        copper.position.x = -0.6; g.add(copper);
        return g;
    },
    gear: () => {
        const g = new THREE.Group();
        const main = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.2, 10), new THREE.MeshStandardMaterial({ color: CONFIG.colors.gear }));
        main.rotation.x = Math.PI/2; g.add(main);
        return g;
    },
    washer: () => {
        const m = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.05, 8, 16), new THREE.MeshStandardMaterial({ color: CONFIG.colors.washer, metalness: 1.0 }));
        m.rotation.y = Math.PI/2; return m;
    },
    controller: () => {
        const g = new THREE.Group();
        g.add(new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 3), new THREE.MeshStandardMaterial({ color: CONFIG.colors.controller })));
        const chip = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        chip.position.y = 0.1; g.add(chip);
        return g;
    },
    sensor: () => {
        const g = new THREE.Group();
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.5), new THREE.MeshStandardMaterial({ color: 0x333 })));
        const eye = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.2, 12), new THREE.MeshBasicMaterial({ color: CONFIG.colors.sensor }));
        eye.rotation.x = Math.PI/2; eye.position.set(-0.2, 0, 0.3); g.add(eye);
        const eye2 = eye.clone(); eye2.position.set(0.2, 0, 0.3); g.add(eye2);
        return g;
    },
    battery: () => {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 1.8, 16), new THREE.MeshStandardMaterial({ color: CONFIG.colors.battery }));
        body.rotation.z = Math.PI/2; g.add(body);
        const pos = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.2, 16), new THREE.MeshStandardMaterial({color: 0xcccccc}));
        pos.rotation.z = Math.PI/2; pos.position.x = 0.8; g.add(pos);
        const stripe = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.36, 0.2, 16), new THREE.MeshBasicMaterial({color: 0xffff00}));
        stripe.rotation.z = Math.PI/2; stripe.position.x = 0.4; g.add(stripe);
        return g;
    },
    batteryCover: () => new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1.5), new THREE.MeshStandardMaterial({color: 0x222})),
    cover: () => {
        const g = new THREE.Group();
        const shape = new THREE.Shape(); shape.moveTo(-1.5, -2.5); shape.lineTo(1.5, -2.5); shape.lineTo(1.5, 2.5); shape.lineTo(-1.5, 2.5);
        const geo = new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.1, bevelThickness: 0.1 });
        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: CONFIG.colors.chassisMain }));
        mesh.rotation.x = Math.PI/2; mesh.position.y = -0.1; g.add(mesh);
        
        // Simple Screen
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1), new THREE.MeshBasicMaterial({ color: 0x000 }));
        screen.rotation.x = -Math.PI/2; screen.position.set(0, 0.12, 1); screen.name = "MainScreen"; g.add(screen);
        return g;
    },
    button: () => {
        const g = new THREE.Group();
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.3), new THREE.MeshStandardMaterial({color: 0x333})));
        const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.15, 16), new THREE.MeshStandardMaterial({color: 0xff0000}));
        btn.position.y = 0.1; g.add(btn); return g;
    }
};

const INVENTORY = [
    { id: 'wheel', count: 4, phase: CONFIG.phases.MECH },
    { id: 'gear', count: 7, phase: CONFIG.phases.MECH },
    { id: 'motor', count: 2, phase: CONFIG.phases.MECH },
    { id: 'washer', count: 4, phase: CONFIG.phases.MECH, reqPart: 'wheel' },
    { id: 'controller', count: 1, phase: CONFIG.phases.ELEC },
    { id: 'sensor', count: 3, phase: CONFIG.phases.ELEC },
    { id: 'battery', count: 2, phase: CONFIG.phases.POWER },
    { id: 'batteryCover', count: 1, phase: CONFIG.phases.POWER, reqPart: 'battery' },
    { id: 'cover', count: 1, phase: CONFIG.phases.POWER },
    { id: 'button', count: 4, phase: CONFIG.phases.POWER, reqPart: 'cover' }
];

const SLOTS = [
    { id: 'w_fl', type: 'wheel', pos: [-2.2, 0, -2], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'w_fr', type: 'wheel', pos: [2.2, 0, -2], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'w_bl', type: 'wheel', pos: [-2.2, 0, 2], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'w_br', type: 'wheel', pos: [2.2, 0, 2], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'm_l', type: 'motor', pos: [-1.2, 0.5, 1], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'm_r', type: 'motor', pos: [1.2, 0.5, 1], rot: [0,0,0], phase: CONFIG.phases.MECH },
    { id: 'g_l1', type: 'gear', pos: [-1.4, 0.5, -0.5], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_l2', type: 'gear', pos: [-1.4, 0.5, 0.2], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_l3', type: 'gear', pos: [-1.4, 0.5, 1.5], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_l4', type: 'gear', pos: [-1.4, 0.5, -1.2], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_r1', type: 'gear', pos: [1.4, 0.5, -0.5], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_r2', type: 'gear', pos: [1.4, 0.5, 0.2], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'g_r3', type: 'gear', pos: [1.4, 0.5, 1.5], rot: [0,0,Math.PI/2], phase: CONFIG.phases.MECH },
    { id: 'ctrl', type: 'controller', pos: [0, 0.6, 0], rot: [0,0,0], phase: CONFIG.phases.ELEC },
    { id: 's_f1', type: 'sensor', pos: [-0.8, 0.6, -2.4], rot: [0,0,0], phase: CONFIG.phases.ELEC },
    { id: 's_f2', type: 'sensor', pos: [0.8, 0.6, -2.4], rot: [0,0,0], phase: CONFIG.phases.ELEC },
    { id: 's_b1', type: 'sensor', pos: [0, 0.6, 2.4], rot: [0, Math.PI, 0], phase: CONFIG.phases.ELEC },
    { id: 'bat1', type: 'battery', pos: [0.5, -0.4, 0], rot: [0,0,0], phase: CONFIG.phases.POWER },
    { id: 'bat2', type: 'battery', pos: [-0.5, -0.4, 0], rot: [0,0,0], phase: CONFIG.phases.POWER },
    { id: 'batcov', type: 'batteryCover', pos: [0, -0.6, 0], rot: [0,0,0], phase: CONFIG.phases.POWER, reqPart: 'battery' },
    { id: 'cov', type: 'cover', pos: [0, 1.2, 0], rot: [0,0,0], phase: CONFIG.phases.POWER },
    { id: 'btn_l', type: 'button', pos: [-0.6, 1.3, -0.5], rot: [0,0,0], phase: CONFIG.phases.POWER, reqPart: 'cover' },
    { id: 'btn_c', type: 'button', pos: [0, 1.3, -0.5], rot: [0,0,0], phase: CONFIG.phases.POWER, reqPart: 'cover' },
    { id: 'btn_r', type: 'button', pos: [0.6, 1.3, -0.5], rot: [0,0,0], phase: CONFIG.phases.POWER, reqPart: 'cover' },
    { id: 'btn_d', type: 'button', pos: [0, 1.3, 0.5], rot: [0,0,0], phase: CONFIG.phases.POWER, reqPart: 'cover' }
];

const Game = {
    init() {
        if (typeof THREE === 'undefined') {
            document.getElementById('status-msg').innerText = "ПОМИЛКА: Немає інтернету для 3D";
            document.getElementById('status-msg').style.color = "red";
            return;
        }

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050505); // DARK BG FIX
        this.scene.fog = new THREE.Fog(0x050505, 10, 50);

        this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.set(6, 6, 8);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);

        const amb = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(5, 10, 5);
        dir.castShadow = true;
        this.scene.add(dir);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;

        // Ground
        const grid = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
        this.scene.add(grid);
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({ color: 0x050505 }));
        plane.rotation.x = -Math.PI/2;
        plane.receiveShadow = true;
        plane.position.y = -0.01;
        this.scene.add(plane);

        // Logic Init
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        this.carGroup = new THREE.Group();
        this.loosePartsGroup = new THREE.Group();
        this.slotMeshes = [];
        this.partsPlaced = {};

        this.buildChassis();
        this.scene.add(this.carGroup);
        this.scene.add(this.loosePartsGroup);

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.addEventListener('mousemove', e => this.onMouseMove(e));
        window.addEventListener('mousedown', e => this.onMouseDown(e));

        this.startPhase(0);
        this.animate();
        this.showToast("БіБіп: Знайди деталі навколо машини");
    },

    buildChassis() {
        const chassis = new THREE.Group();
        const main = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 5), new THREE.MeshStandardMaterial({ color: CONFIG.colors.chassisMain, roughness: 0.3, metalness: 0.5 }));
        main.castShadow = true; main.receiveShadow = true; chassis.add(main);
        const cockpit = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.5, 3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        cockpit.position.y = 0.6; chassis.add(cockpit);
        const fAxle = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 4.2, 8), new THREE.MeshStandardMaterial({color: 0x222}));
        fAxle.rotation.z = Math.PI/2; fAxle.position.z = -2; chassis.add(fAxle);
        const bAxle = fAxle.clone(); bAxle.position.z = 2; chassis.add(bAxle);
        const batSlot = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 3), new THREE.MeshStandardMaterial({color: 0x000}));
        batSlot.position.y = -0.41; chassis.add(batSlot);
        this.carGroup.add(chassis);
    },

    startPhase(p) {
        this.currentPhase = p;
        const titles = ["Етап 1: Ходова", "Етап 2: Електроніка", "Етап 3: Живлення", "Етап 4: ТЕСТ-ДРАЙВ"];
        document.getElementById('phase-badge').innerText = titles[p];
        document.getElementById('status-msg').innerText = ["Почни з коліс", "Встанови плату", "Встав батарейки знизу", "Поїхали! (WASD)"][p];
        
        this.selectedLoosePart = null;
        this.spawnPhaseParts();
        this.createSlots();
        this.checkProgress();
        
        if (p === 2) { // POWER
            new TWEEN.Tween(this.camera.position).to({x: 5, y: -4, z: 5}, 1500).easing(TWEEN.Easing.Quadratic.Out).start();
            this.showToast("Перевертаємо...");
        } else if (p < 3) {
            new TWEEN.Tween(this.camera.position).to({x: 6, y: 6, z: 8}, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        }
    },

    spawnPhaseParts() {
        while(this.loosePartsGroup.children.length) this.loosePartsGroup.remove(this.loosePartsGroup.children[0]);
        INVENTORY.forEach(item => {
            if (item.phase === this.currentPhase) {
                for(let i=0; i<item.count; i++) {
                    const mesh = PartFactory[item.id]();
                    const angle = Math.random() * Math.PI * 2;
                    const rad = 6 + Math.random() * 2;
                    mesh.position.set(Math.cos(angle)*rad, 0.5, Math.sin(angle)*rad);
                    mesh.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Interaction sphere (Transparent but visible to raycaster)
                    const hitGeo = new THREE.SphereGeometry(1.5, 8, 8);
                    const hitMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 }); 
                    const hit = new THREE.Mesh(hitGeo, hitMat);
                    mesh.add(hit);
                    
                    mesh.userData = { type: item.id, isLoose: true };
                    this.loosePartsGroup.add(mesh);
                }
            }
        });
    },

    createSlots() {
        this.slotMeshes.forEach(m => this.carGroup.remove(m));
        this.slotMeshes = [];
        SLOTS.forEach(slotDef => {
            if (slotDef.phase !== this.currentPhase) return;
            if (slotDef.reqPart === 'cover' && !this.partsPlaced['cov']) return;
            if (slotDef.reqPart === 'battery' && (!this.partsPlaced['bat1'] || !this.partsPlaced['bat2'])) return;

            const geo = new THREE.SphereGeometry(0.3, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.highlight, transparent: true, opacity: 0.4, wireframe: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(...slotDef.pos);
            mesh.userData = { isSlot: true, def: slotDef };
            
            new TWEEN.Tween(mesh.scale).to({x:1.3, y:1.3, z:1.3}, 800).yoyo(true).repeat(Infinity).start();
            this.carGroup.add(mesh);
            this.slotMeshes.push(mesh);
        });
    },

    onMouseMove(e) {
        if(this.currentPhase === 3) return;
        this.mouse.x = (e.clientX/window.innerWidth)*2-1;
        this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
        
        const tooltip = document.getElementById('cursor-tooltip');
        tooltip.style.left = e.clientX+15+'px'; tooltip.style.top = e.clientY+15+'px';
        tooltip.style.display = 'none'; document.body.style.cursor = 'default';

        this.raycaster.setFromCamera(this.mouse, this.camera);

        // DRAGGING
        if (this.selectedLoosePart) {
            const intersect = new THREE.Vector3();
            this.raycaster.ray.intersectPlane(this.dragPlane, intersect);
            if (intersect) {
                this.selectedLoosePart.position.x = intersect.x;
                this.selectedLoosePart.position.z = intersect.z;
            }
        }

        const slots = this.raycaster.intersectObjects(this.slotMeshes);
        if (slots.length > 0) {
            tooltip.style.display = 'block';
            tooltip.innerText = `Слот: ${slots[0].object.userData.def.type}`;
            document.body.style.cursor = 'pointer';
            return;
        }

        const parts = this.raycaster.intersectObjects(this.loosePartsGroup.children, true);
        if (parts.length > 0) {
            let obj = parts[0].object;
            while(obj.parent !== this.loosePartsGroup) obj = obj.parent;
            if (obj !== this.selectedLoosePart) {
                tooltip.style.display = 'block';
                tooltip.innerText = `Взяти: ${obj.userData.type}`;
                document.body.style.cursor = 'grab';
            }
        }
    },

    onMouseDown(e) {
        if (e.button !== 0 || this.currentPhase === 3) return;
        this.raycaster.setFromCamera(this.mouse, this.camera);

        const slots = this.raycaster.intersectObjects(this.slotMeshes);
        if (slots.length > 0) {
            this.handleSlotClick(slots[0].object);
            return;
        }

        const parts = this.raycaster.intersectObjects(this.loosePartsGroup.children, true);
        if (parts.length > 0) {
            let obj = parts[0].object;
            while(obj.parent !== this.loosePartsGroup) obj = obj.parent;
            if (this.selectedLoosePart === obj) this.dropPart();
            else { if(this.selectedLoosePart) this.dropPart(); this.pickupPart(obj); }
        } else if (this.selectedLoosePart) {
            this.dropPart();
        }
    },

    pickupPart(obj) {
        this.selectedLoosePart = obj;
        new TWEEN.Tween(obj.position).to({y: 2}, 200).easing(TWEEN.Easing.Back.Out).start();
        this.showToast("Взяв: " + obj.userData.type);
    },

    dropPart() {
        if(!this.selectedLoosePart) return;
        new TWEEN.Tween(this.selectedLoosePart.position).to({y: 0.5}, 400).easing(TWEEN.Easing.Bounce.Out).start();
        this.selectedLoosePart = null;
    },

    handleSlotClick(slotMesh) {
        if (!this.selectedLoosePart) { this.showToast("Спочатку візьми деталь", true); return; }
        const def = slotMesh.userData.def;
        const type = this.selectedLoosePart.userData.type;
        
        let valid = (type === def.type);
        if (type === 'washer' && def.type === 'wheel') valid = true;

        if (!valid) { this.showToast("Не підходить!", true); return; }

        if (type === 'washer') {
            const wheel = this.partsPlaced[def.id];
            if (wheel && !wheel.userData.hasWasher) {
                const w = PartFactory.washer();
                w.position.x = (def.pos[0]>0)?0.6:-0.6;
                wheel.add(w);
                wheel.userData.hasWasher = true;
                wheel.userData.wobble = false;
                wheel.rotation.set(...def.rot);
                this.finalizePlacement(slotMesh);
            }
            return;
        }

        const mesh = PartFactory[type]();
        mesh.position.set(...def.pos);
        mesh.rotation.set(...def.rot);
        mesh.castShadow = true; mesh.receiveShadow = true;
        this.carGroup.add(mesh);
        this.partsPlaced[def.id] = mesh;

        if (type === 'wheel') {
            mesh.userData.wobble = true;
            slotMesh.material.color.setHex(0xffff00);
            slotMesh.scale.set(0.5,0.5,0.5);
        } else {
            this.carGroup.remove(slotMesh);
            this.slotMeshes = this.slotMeshes.filter(m => m!==slotMesh);
        }
        this.finalizePlacement(slotMesh);
    },

    finalizePlacement() {
        this.loosePartsGroup.remove(this.selectedLoosePart);
        this.selectedLoosePart = null;
        this.checkProgress();
    },

    checkProgress() {
        const remaining = this.loosePartsGroup.children.length;
        const wheels = ['w_fl','w_fr','w_bl','w_br'];
        const unsafe = wheels.filter(id => this.partsPlaced[id] && !this.partsPlaced[id].userData.hasWasher).length;
        
        const btn = document.getElementById('next-btn');
        if(remaining === 0 && unsafe === 0) {
            btn.disabled = false;
            this.showToast("Готово! Тисни ДАЛІ");
        } else {
            btn.disabled = true;
        }
    },

    nextPhase() {
        if (this.currentPhase < 3) this.startPhase(this.currentPhase + 1);
        if (this.currentPhase === 3) this.startTestDrive();
    },

    startTestDrive() {
        this.showToast("Тест-драйв!");
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
    },
    
    keys: {}, speed: 0, angle: 0,

    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        this.controls.update();

        // Wobble
        const t = Date.now() * 0.005;
        for (let id in this.partsPlaced) {
            if(this.partsPlaced[id].userData.wobble) this.partsPlaced[id].rotation.x = Math.sin(t*15)*0.15;
        }

        // Drive
        if(this.currentPhase === 3) {
            if(this.keys['w']) this.speed += 0.005;
            if(this.keys['s']) this.speed -= 0.003;
            this.speed *= 0.95;
            if(Math.abs(this.speed)>0.001) {
                if(this.keys['a']) this.angle += 0.03*Math.sign(this.speed);
                if(this.keys['d']) this.angle -= 0.03*Math.sign(this.speed);
            }
            this.carGroup.position.x += Math.cos(this.angle)*this.speed*10;
            this.carGroup.position.z -= Math.sin(this.angle)*this.speed*10;
            this.carGroup.rotation.y = this.angle + Math.PI/2;
            
            ['w_fl','w_fr','w_bl','w_br'].forEach(id => {
                if(this.partsPlaced[id]) this.partsPlaced[id].children[0].rotation.x -= this.speed * 20;
            });

            // Cam follow
            const target = new THREE.Vector3(0,5,8).applyMatrix4(this.carGroup.matrixWorld);
            this.camera.position.lerp(target, 0.05);
            this.camera.lookAt(this.carGroup.position);
        }

        this.renderer.render(this.scene, this.camera);
    },

    showToast(msg, err) {
        const d = document.createElement('div'); d.className='toast'; d.innerText=msg;
        if(err) d.style.borderLeftColor = 'red';
        document.getElementById('toast-container').appendChild(d);
        setTimeout(()=>d.remove(), 2500);
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>
