<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TNTU AR Neural Interface v3.0 [Clean View]</title>
    
    <style>
        :root {
            --primary: #00ffcc;
            --secondary: #008f7a;
            --bg: #000000;
            --font-main: 'Segoe UI', 'Roboto', sans-serif;
            --font-mono: 'Courier New', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: var(--font-main);
            color: var(--primary);
            user-select: none;
        }

        /* --- ЕКРАН ЗАВАНТАЖЕННЯ --- */
        #loader {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #050505;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .loader-ring {
            width: 50px; height: 50px;
            border: 3px solid transparent;
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        #btn-start {
            padding: 15px 40px;
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
        }

        #btn-start:hover {
            background: rgba(0, 255, 204, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.4);
        }

        /* --- ГОЛОВНИЙ ЕКРАН --- */
        #viewport {
            position: relative;
            width: 100vw; height: 100vh;
        }

        #video-feed {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.7) contrast(1.1);
            z-index: 0;
        }

        #ar-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
        }

        /* --- HUD (МІНІМАЛІСТИЧНИЙ) --- */
        #hud {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 900px;
            z-index: 20;
            text-align: center;
            pointer-events: none; /* Пропускає кліки крізь текст */
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .task-label {
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .task-text {
            font-size: 1.4rem;
            color: #fff;
            font-weight: 600;
            background: rgba(0,0,0,0.4);
            padding: 10px 20px;
            border-radius: 8px;
            display: inline-block;
            border-bottom: 2px solid var(--primary);
            margin-bottom: 15px;
        }

        .input-buffer {
            font-family: var(--font-mono);
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
            min-height: 2.5rem;
            margin: 10px 0;
            text-shadow: 0 0 15px var(--primary);
        }

        .instructions {
            font-size: 0.85rem;
            color: #ffeb3b;
            opacity: 0.9;
            margin-top: 5px;
            animation: pulse 3s infinite;
        }

        .success-anim {
            animation: successFlash 0.5s ease-out;
            color: #00ff00 !important;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        @keyframes successFlash { 0% { transform: scale(1); } 50% { transform: scale(1.2); color: #fff; } 100% { transform: scale(1); } }

        /* Консоль помилок (прихована, але доступна в коді) */
        #debug-log { display: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <h2 style="margin-bottom: 20px; font-weight: normal;">AR INPUT SYSTEM v3.0</h2>
        <button id="btn-start">ЗАПУСТИТИ СИСТЕМУ</button>
    </div>

    <div id="viewport">
        <video id="video-feed" playsinline muted></video>
        <canvas id="ar-canvas"></canvas>

        <div id="hud">
            <div class="task-label">ЗАВДАННЯ</div>
            <div class="task-text">Введіть текст: <span style="color:#fff">кафедра приладів і контрольно-вимірювальних систем</span></div>
            
            <div class="input-buffer" id="user-input">...</div>
            
            <div class="instructions">
                ℹ️ З'єднайте <b>ВЕЛИКИЙ</b> та <b>ВКАЗІВНИЙ</b> пальці для кліку
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TNTU AR SYSTEM CORE - "Clean Edition"
 * Architecture: Component-Based
 * Modules: Config, MathUtils, Particles, Logic, Input, Render
 * Lines of Code Strategy: Robust implementation of Physics & Particles
 * ============================================================================
 */

// --- 1. CONFIGURATION ---
const CONFIG = {
    CAMERA: { WIDTH: 1280, HEIGHT: 720 },
    KEYBOARD: {
        POS_Z: -6.5,          // Відстань від камери
        SCALE: 1.4,           // Розмір клавіатури
        SPACING: 0.08,        // Відступи
        TARGET_PHRASE: "кафедра приладів і контрольно-вимірювальних систем"
    },
    COLORS: {
        KEY_IDLE: 0x002233,
        KEY_HOVER: 0x005577,
        KEY_ACTIVE: 0x00ffcc,
        TEXT: 0xffffff,
        PARTICLE: 0x00ffcc,
        CONNECTOR_OPEN: 0xffff00, // Жовтий (відкрито)
        CONNECTOR_CLOSE: 0x00ff00 // Зелений (натиснуто)
    },
    VALIDATION: {
        // Логіка визначення кліку
        PINCH_THRESHOLD: 0.035,   // Поріг відстані для старту кліку
        PINCH_RELEASE: 0.05,      // Поріг для відпускання
        VELOCITY_LIMIT: 0.1,      // Максимальна швидкість руки
        COOLDOWN: 350,            // Мс між кліками
        SMOOTHING: 0.2            // Коефіцієнт згладжування (0-1)
    },
    PARTICLES: {
        COUNT: 20,                // Частинок на один клік
        SPEED: 0.05,
        DECAY: 0.02
    }
};

// --- 2. MATH UTILITIES ---
const MathUtils = {
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    
    // Векторна інтерполяція для плавності
    smoothVector: (current, target, factor) => {
        if (!current) return target.clone();
        current.x = MathUtils.lerp(current.x, target.x, factor);
        current.y = MathUtils.lerp(current.y, target.y, factor);
        current.z = MathUtils.lerp(current.z, target.z, factor);
        return current;
    },

    // Відстань між 2D точками (для стабільності кліку)
    dist2D: (p1, p2, aspect) => {
        const dx = (p1.x - p2.x) * aspect; // Корекція на співвідношення сторін
        const dy = p1.y - p2.y;
        return Math.sqrt(dx*dx + dy*dy);
    }
};

// --- 3. PARTICLE SYSTEM (VISUAL FX) ---
/**
 * Advanced Particle System for typing feedback.
 * Spawns digital sparks when keys are pressed.
 */
class ParticleSystem {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        // Базова геометрія частинки
        this.geometry = new THREE.PlaneGeometry(0.05, 0.05);
        this.material = new THREE.MeshBasicMaterial({
            color: CONFIG.COLORS.PARTICLE,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
    }

    spawn(position, count = CONFIG.PARTICLES.COUNT) {
        for (let i = 0; i < count; i++) {
            const mesh = new THREE.Mesh(this.geometry, this.material.clone());
            mesh.position.copy(position);
            
            // Випадковий розліт
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                (Math.random() - 0.5) * 0.3,
                (Math.random() - 0.5) * 0.2 + 0.1 // Трохи вгору
            );

            this.particles.push({
                mesh: mesh,
                velocity: velocity,
                life: 1.0, // Життя від 1.0 до 0
                rotSpeed: (Math.random() - 0.5) * 0.2
            });

            this.scene.add(mesh);
        }
    }

    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            
            // Фізика руху
            p.mesh.position.add(p.velocity);
            p.mesh.rotation.z += p.rotSpeed;
            
            // Гравітація (легка)
            p.velocity.y -= 0.005;

            // Життєвий цикл
            p.life -= CONFIG.PARTICLES.DECAY;
            p.mesh.material.opacity = p.life;
            p.mesh.scale.setScalar(p.life);

            // Видалення мертвих частинок
            if (p.life <= 0) {
                this.scene.remove(p.mesh);
                // Звільнення пам'яті матеріалу
                p.mesh.material.dispose();
                this.particles.splice(i, 1);
            }
        }
    }
}

// --- 4. KEYBOARD ENTITIES ---
class VirtualKey {
    constructor(char, x, y, w, h) {
        this.char = char;
        this.mesh = new THREE.Group();
        this.mesh.position.set(x, y, 0);

        // 1. Основний корпус
        const geoBox = new THREE.BoxGeometry(w, h, 0.05);
        this.matBody = new THREE.MeshPhongMaterial({
            color: CONFIG.COLORS.KEY_IDLE,
            transparent: true,
            opacity: 0.9,
            shininess: 50
        });
        this.body = new THREE.Mesh(geoBox, this.matBody);
        
        // 2. Рамка (для кращої видимості)
        const edges = new THREE.EdgesGeometry(geoBox);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00aaaa, opacity: 0.3, transparent: true });
        this.border = new THREE.LineSegments(edges, lineMat);

        // 3. Текст
        this.label = this._createLabel(char, w, h);
        
        this.mesh.add(this.body);
        this.mesh.add(this.border);
        this.mesh.add(this.label);

        // UserData для Raycaster
        this.body.userData = { parentKey: this };
    }

    _createLabel(char, w, h) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = 'rgba(0,0,0,0)'; // Прозорий фон
        ctx.fillRect(0,0,128,128);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 64px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Спецсимволи
        let txt = char;
        if(char === 'SPACE') txt = '␣';
        if(char === 'DEL') txt = '←';

        ctx.fillText(txt, 64, 64);
        
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        const geo = new THREE.PlaneGeometry(w*0.8, h*0.8);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.z = 0.06; // Трохи вище кнопки
        return mesh;
    }

    setState(state) {
        switch(state) {
            case 'press':
                this.matBody.color.setHex(CONFIG.COLORS.KEY_ACTIVE);
                this.matBody.emissive.setHex(0x004433);
                this.body.scale.z = 0.5; // Вдавлення
                break;
            case 'hover':
                this.matBody.color.setHex(CONFIG.COLORS.KEY_HOVER);
                this.matBody.emissive.setHex(0x001122);
                this.body.scale.z = 1.0;
                break;
            default: // idle
                this.matBody.color.setHex(CONFIG.COLORS.KEY_IDLE);
                this.matBody.emissive.setHex(0x000000);
                this.body.scale.z = 1.0;
        }
    }
}

class KeyboardManager {
    constructor(scene) {
        this.scene = scene;
        this.keys = [];
        this.group = new THREE.Group();
        this.buffer = "";
        
        this._initLayout();
        
        this.scene.add(this.group);
        this.group.position.z = CONFIG.KEYBOARD.POS_Z;
        this.group.scale.setScalar(CONFIG.KEYBOARD.SCALE);
    }

    _initLayout() {
        const rows = [
            ['Й','Ц','У','К','Е','Н','Г','Ш','Щ','З','Х','Ї'],
            ['Ф','І','В','А','П','Р','О','Л','Д','Ж','Є'],
            ['Я','Ч','С','М','И','Т','Ь','Б','Ю','-','DEL'],
            ['SPACE']
        ];
        
        const keyW = 0.5; 
        const keyH = 0.5; 
        const gap = CONFIG.KEYBOARD.SPACING;
        let cy = 0;

        rows.forEach(row => {
            // Центрування ряду
            let rowW = row.length * (keyW + gap) - gap;
            if(row[0] === 'SPACE') rowW = (3 + gap) - gap; // Корекція для пробілу
            
            let cx = -rowW / 2 + keyW / 2;

            row.forEach(char => {
                let w = keyW;
                if(char === 'SPACE') { w = 3; cx = 0; } // Пробіл по центру

                const key = new VirtualKey(char, cx, cy, w, keyH);
                this.keys.push(key);
                this.group.add(key.mesh);

                if(char !== 'SPACE') cx += w + gap;
            });
            cy -= (keyH + gap);
        });
    }

    resetState() {
        this.keys.forEach(k => k.setState('idle'));
    }

    type(char) {
        if(char === 'DEL') this.buffer = this.buffer.slice(0, -1);
        else if(char === 'SPACE') this.buffer += ' ';
        else this.buffer += char.toLowerCase();

        this._updateUI();
    }

    _updateUI() {
        const el = document.getElementById('user-input');
        el.innerText = this.buffer || "...";
        
        // Перевірка на успіх
        if(this.buffer.trim() === CONFIG.KEYBOARD.TARGET_PHRASE) {
            el.classList.add('success-anim');
            el.innerHTML += " <br>✅ ЗАВДАННЯ ВИКОНАНО!";
        } else {
            el.classList.remove('success-anim');
        }
    }

    getColliders() {
        return this.keys.map(k => k.body);
    }
}

// --- 5. LOGIC & INPUT SYSTEM ---
class InputController {
    constructor(scene, camera, keyboard, particles) {
        this.scene = scene;
        this.camera = camera;
        this.keyboard = keyboard;
        this.particles = particles;
        
        this.raycaster = new THREE.Raycaster();
        
        // Візуалізація курсору
        this.cursorGroup = new THREE.Group();
        this.scene.add(this.cursorGroup);
        
        // 1. Точка центру (Курсор)
        const dotGeo = new THREE.SphereGeometry(0.04, 16, 16);
        this.cursorDot = new THREE.Mesh(dotGeo, new THREE.MeshBasicMaterial({color: 0xffff00}));
        
        // 2. Лінія з'єднання пальців ("Дві лінії", які просив користувач - насправді одна лінія між пальцями)
        // Ми зробимо це як динамічну лінію
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
        this.connectorLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
            color: CONFIG.COLORS.CONNECTOR_OPEN, 
            linewidth: 3 
        }));
        
        // 3. Кільце прогресу
        const ringGeo = new THREE.RingGeometry(0.06, 0.07, 32);
        this.cursorRing = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({
            color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5
        }));

        this.cursorGroup.add(this.cursorDot);
        this.cursorGroup.add(this.connectorLine); // Додаємо лінію до групи
        this.cursorGroup.add(this.cursorRing);
        
        this.cursorGroup.visible = false;

        // Змінні стану
        this.smoothIndex = null;
        this.smoothThumb = null;
        this.isPinching = false;
        this.lastClick = 0;
        this.velocity = 0;
    }

    update(landmarks) {
        if(!landmarks) {
            this.cursorGroup.visible = false;
            return;
        }
        this.cursorGroup.visible = true;

        // 1. Отримання координат 3D
        // Індекс 8 (Вказівний), 4 (Великий)
        const rawIndex = this._projectFinger(landmarks[8]);
        const rawThumb = this._projectFinger(landmarks[4]);

        // 2. Згладжування руху (Low-pass filter)
        this.smoothIndex = MathUtils.smoothVector(this.smoothIndex, rawIndex, CONFIG.VALIDATION.SMOOTHING);
        this.smoothThumb = MathUtils.smoothVector(this.smoothThumb, rawThumb, CONFIG.VALIDATION.SMOOTHING);

        // 3. Розрахунок центру курсору
        const center = new THREE.Vector3().addVectors(this.smoothIndex, this.smoothThumb).multiplyScalar(0.5);
        this.cursorDot.position.copy(center);
        this.cursorRing.position.copy(center);

        // 4. Оновлення лінії з'єднання (ТІ САМІ ЛІНІЇ)
        // Лінія малюється між реальними положеннями пальців
        const positions = this.connectorLine.geometry.attributes.position.array;
        
        // Точка 1 (Вказівний)
        positions[0] = this.smoothIndex.x;
        positions[1] = this.smoothIndex.y;
        positions[2] = this.smoothIndex.z;
        
        // Точка 2 (Великий)
        positions[3] = this.smoothThumb.x;
        positions[4] = this.smoothThumb.y;
        positions[5] = this.smoothThumb.z;
        
        this.connectorLine.geometry.attributes.position.needsUpdate = true;

        // 5. Логіка кліку (на основі 2D відстані екрану для стабільності)
        const aspect = window.innerWidth / window.innerHeight;
        const dist2d = MathUtils.dist2D(landmarks[8], landmarks[4], aspect);

        // Гістерезис
        const threshold = this.isPinching ? CONFIG.VALIDATION.PINCH_RELEASE : CONFIG.VALIDATION.PINCH_THRESHOLD;
        const pinchDetected = dist2d < threshold;

        // Візуалізація стану
        if (pinchDetected) {
            this.connectorLine.material.color.setHex(CONFIG.COLORS.CONNECTOR_CLOSE);
            this.cursorDot.material.color.setHex(CONFIG.COLORS.CONNECTOR_CLOSE);
            this.cursorRing.scale.setScalar(0.5);
        } else {
            this.connectorLine.material.color.setHex(CONFIG.COLORS.CONNECTOR_OPEN);
            this.cursorDot.material.color.setHex(CONFIG.COLORS.CONNECTOR_OPEN);
            this.cursorRing.scale.setScalar(1.0);
        }

        // Обробка події (Raycast)
        this._processInteraction(center, pinchDetected);
        this.isPinching = pinchDetected;
    }

    _projectFinger(lm) {
        // Конвертація з нормалізованих координат (0..1) в 3D простір
        // X інвертуємо (1 - x), бо камера дзеркальна
        const x = (1 - lm.x) * 2 - 1; 
        const y = -lm.y * 2 + 1;
        
        const vec = new THREE.Vector3(x, y, 0.5);
        vec.unproject(this.camera);
        
        const dir = vec.sub(this.camera.position).normalize();
        const dist = (CONFIG.KEYBOARD.POS_Z + 1 - this.camera.position.z) / dir.z;
        
        return this.camera.position.clone().add(dir.multiplyScalar(dist));
    }

    _processInteraction(cursorPos, isPinchingNow) {
        // Конвертуємо 3D курсор назад в 2D для Raycaster
        const screenPos = cursorPos.clone().project(this.camera);
        this.raycaster.setFromCamera(new THREE.Vector2(screenPos.x, screenPos.y), this.camera);

        const intersects = this.raycaster.intersectObjects(this.keyboard.getColliders());
        
        // Скидаємо підсвітку
        this.keyboard.resetState();

        if(intersects.length > 0) {
            const hitKey = intersects[0].object.userData.parentKey;
            
            if(hitKey) {
                const now = Date.now();
                // Логіка: Rising Edge (Тільки момент натискання) + Cooldown
                if(isPinchingNow && !this.isPinching && (now - this.lastClick > CONFIG.VALIDATION.COOLDOWN)) {
                    
                    // КЛІК!
                    hitKey.setState('press');
                    this.keyboard.type(hitKey.char);
                    this.lastClick = now;
                    
                    // Ефект частинок
                    this.particles.spawn(cursorPos);
                    
                    // Вібрація (якщо мобільний)
                    if(navigator.vibrate) navigator.vibrate(30);

                } else if (isPinchingNow) {
                    // Утримання
                    hitKey.setState('press');
                } else {
                    // Наведення
                    hitKey.setState('hover');
                }
            }
        }
    }
}

// --- 6. MAIN SYSTEM ---
class ARApp {
    constructor() {
        this.video = document.getElementById('video-feed');
        this.canvas = document.getElementById('ar-canvas');
        
        // Ініціалізація Three.js
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.z = 5;
        
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Світло
        const ambi = new THREE.AmbientLight(0xffffff, 0.7);
        const dir = new THREE.DirectionalLight(0x00ffcc, 0.5);
        dir.position.set(0, 5, 2);
        this.scene.add(ambi, dir);

        // Компоненти
        this.particles = new ParticleSystem(this.scene);
        this.keyboard = new KeyboardManager(this.scene);
        this.input = new InputController(this.scene, this.camera, this.keyboard, this.particles);

        // Ресайз
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    start() {
        // MediaPipe Hands Init
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults((results) => {
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                this.input.update(results.multiHandLandmarks[0]);
            } else {
                this.input.update(null);
            }
        });

        const cam = new Camera(this.video, {
            onFrame: async () => await hands.send({image: this.video}),
            width: 1280, height: 720
        });
        
        cam.start();
        this._loop();
    }

    _loop() {
        requestAnimationFrame(this._loop.bind(this));
        
        // Оновлення частинок
        this.particles.update();
        
        this.renderer.render(this.scene, this.camera);
    }
}

// --- ЗАПУСК ---
document.getElementById('btn-start').addEventListener('click', () => {
    const loader = document.getElementById('loader');
    loader.style.opacity = '0';
    setTimeout(() => {
        loader.style.display = 'none';
        const app = new ARApp();
        app.start();
    }, 500);
});

</script>
</body>
</html>
