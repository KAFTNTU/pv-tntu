<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Neural Interface v4.1 [Fixed Mirror & Scale]</title>
    
    <style>
        :root {
            --primary: #00ffcc;
            --secondary: #0088aa;
            --danger: #ff3333;
            --bg: #050510;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', 'Roboto Mono', monospace;
            color: var(--primary);
            user-select: none;
        }

        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* ВІДЕО ФОН */
        #camera-feed {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Дзеркальне відображення CSS */
            z-index: 0;
            opacity: 0.4;
            filter: contrast(1.1) brightness(0.8);
        }

        /* 3D СЦЕНА */
        #ar-scene {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* ВЕРХНЯ ПАНЕЛЬ (HUD) */
        #hud-layer {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .text-panel {
            background: rgba(0, 20, 30, 0.85);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.15);
            backdrop-filter: blur(4px);
        }

        #output {
            font-size: 1.8rem;
            font-weight: 700;
            min-height: 1.8rem;
            white-space: pre-wrap;
            text-align: center;
            text-shadow: 0 0 5px var(--primary);
            color: #fff;
        }

        #status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #333;
        }
        .dot.active { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
        .dot.error { background: #ff0000; box-shadow: 0 0 8px #ff0000; }

        /* КОНСОЛЬ НАЛАГОДЖЕННЯ */
        #debug-console {
            position: absolute;
            bottom: 10px; left: 10px;
            font-size: 10px;
            color: lime;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            pointer-events: none;
            max-width: 300px;
            max-height: 100px;
            overflow: hidden;
            border-left: 2px solid lime;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="viewport">
        <video id="camera-feed" playsinline muted autoplay></video>
        <canvas id="ar-scene"></canvas>

        <div id="hud-layer">
            <div class="text-panel">
                <div id="output">SYSTEM INITIALIZING...</div>
            </div>
            <div id="status-bar">
                <div class="status-indicator">
                    <div class="dot" id="st-cam"></div> CAM
                </div>
                <div class="status-indicator">
                    <div class="dot" id="st-ai"></div> AI ENGINE
                </div>
                <div class="status-indicator">
                    <div class="dot" id="st-hand"></div> HAND TRACK
                </div>
                <div class="status-indicator">
                    <div class="dot" id="st-pinch"></div> PINCH LOCK
                </div>
            </div>
        </div>

        <div id="debug-console">waiting for logs...</div>
    </div>

<script>
/**
 * ============================================================================
 * NEURAL AR KEYBOARD CORE SYSTEM v5.1 (Fixed Edition)
 * ============================================================================
 */

// --- 1. GLOBAL CONFIGURATION & CONSTANTS ---
const CONFIG = {
    CAMERA: {
        WIDTH: 1280,
        HEIGHT: 720,
        FPS: 30
    },
    INTERACTION: {
        PINCH_THRESHOLD: 0.055,
        PINCH_RELEASE_BUFFER: 0.07,
        SMOOTHING_ALPHA: 0.25,
        RAYCAST_DEPTH: 50,
        COOLDOWN_MS: 350
    },
    KEYBOARD: {
        POS_Z: -6,
        SCALE: 1.6, // <--- ВИПРАВЛЕНО: Збільшено з 0.4 до 1.6 (в 4 рази)
        KEY_SPACING: 0.08,
        KEY_COLOR: 0x002233,
        KEY_ACTIVE: 0x00ffcc,
        KEY_HOVER: 0x005577
    },
    FX: {
        PARTICLE_COUNT: 12,
        CURSOR_SIZE: 0.03
    }
};

// --- 2. MATH UTILITIES & HELPERS ---
const Utils = {
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    smoothVector: (current, target, factor) => {
        current.x = Utils.lerp(current.x, target.x, factor);
        current.y = Utils.lerp(current.y, target.y, factor);
        current.z = Utils.lerp(current.z, target.z, factor);
        return current;
    },
    distSq: (v1, v2) => {
        const dx = v1.x - v2.x;
        const dy = v1.y - v2.y;
        return dx * dx + dy * dy;
    },
    dist2D: (v1, v2) => {
        return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
    },
    log: (msg) => {
        const el = document.getElementById('debug-console');
        if (el) {
            el.innerHTML += `<div>> ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }
        console.log(`[SYS]: ${msg}`);
    },
    setStatus: (id, state) => {
        const el = document.getElementById(id);
        if (el) {
            el.className = `dot ${state ? 'active' : (state === false ? 'error' : '')}`;
        }
    }
};

// --- 3. CLASS: VISUAL EFFECTS (PARTICLES) ---
class ParticleSystem {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        this.geometry = new THREE.PlaneGeometry(0.04, 0.04);
        this.material = new THREE.MeshBasicMaterial({
            color: 0x00ffcc, transparent: true, opacity: 1
        });
    }

    spawn(position) {
        for (let i = 0; i < CONFIG.FX.PARTICLE_COUNT; i++) {
            const mesh = new THREE.Mesh(this.geometry, this.material.clone());
            mesh.position.copy(position);
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            this.particles.push({ mesh, velocity, life: 1.0 });
            this.scene.add(mesh);
        }
    }

    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.mesh.position.add(p.velocity);
            p.mesh.rotation.z += 0.1;
            p.life -= 0.03;
            p.mesh.material.opacity = p.life;
            p.mesh.scale.setScalar(p.life);
            if (p.life <= 0) {
                this.scene.remove(p.mesh);
                this.particles.splice(i, 1);
            }
        }
    }
}

// --- 4. CLASS: VIRTUAL KEY (3D BUTTON) ---
class VirtualKey {
    constructor(char, x, y, w, h) {
        this.char = char;
        this.width = w;
        this.height = h;
        this.isHovered = false;
        this.isPressed = false;
        
        this.mesh = this._createMesh(w, h);
        this.mesh.position.set(x, y, 0);
        
        this.label = this._createLabel(char, w, h);
        this.mesh.add(this.label);
        
        this.mesh.userData = { keyInstance: this };
    }

    _createMesh(w, h) {
        const geo = new THREE.BoxGeometry(w, h, 0.05);
        const mat = new THREE.MeshPhongMaterial({
            color: CONFIG.KEYBOARD.KEY_COLOR,
            transparent: true,
            opacity: 0.85,
            shininess: 80
        });
        return new THREE.Mesh(geo, mat);
    }

    _createLabel(text, w, h) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.font = 'bold 60px "Segoe UI", Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let display = text;
        if (text === 'SPACE') display = '⎵';
        if (text === 'DEL') display = '←';
        
        ctx.fillText(display, 64, 64);
        
        const texture = new THREE.CanvasTexture(canvas);
        const labelGeo = new THREE.PlaneGeometry(w * 0.8, h * 0.8);
        const labelMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        
        const mesh = new THREE.Mesh(labelGeo, labelMat);
        mesh.position.z = 0.06;
        return mesh;
    }

    setState(state) {
        const mat = this.mesh.material;
        if (state === 'press') {
            mat.color.setHex(CONFIG.KEYBOARD.KEY_ACTIVE);
            mat.emissive.setHex(0x00ff00);
            this.mesh.scale.setZ(0.5);
        } else if (state === 'hover') {
            mat.color.setHex(CONFIG.KEYBOARD.KEY_HOVER);
            mat.emissive.setHex(0x002244);
            this.mesh.scale.setZ(1.0);
        } else {
            mat.color.setHex(CONFIG.KEYBOARD.KEY_COLOR);
            mat.emissive.setHex(0x000000);
            this.mesh.scale.setZ(1.0);
        }
    }
}

// --- 5. CLASS: KEYBOARD MANAGER ---
class KeyboardManager {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.keys = [];
        this.typedText = "";
        this._buildLayout();
        this.scene.add(this.group);
        this.group.position.z = CONFIG.KEYBOARD.POS_Z;
        this.group.scale.setScalar(CONFIG.KEYBOARD.SCALE);
    }

    _buildLayout() {
        const layout = [
            ['Й','Ц','У','К','Е','Н','Г','Ш','Щ','З','Х'],
            ['Ф','І','В','А','П','Р','О','Л','Д','Ж','Є'],
            ['Я','Ч','С','М','И','Т','Ь','Б','Ю','DEL'],
            ['SPACE']
        ];
        
        const keyW = 0.5;
        const keyH = 0.5;
        const gap = CONFIG.KEYBOARD.KEY_SPACING;
        let currentY = 0;

        layout.forEach((row) => {
            let rowWidth = row.length * (keyW + gap);
            if (row[0] === 'SPACE') rowWidth = 3 + gap;
            let currentX = -(rowWidth / 2) + keyW / 2;

            row.forEach(char => {
                let w = keyW;
                if (char === 'SPACE') { w = 3; currentX += 1.25; }
                const key = new VirtualKey(char, currentX, currentY, w, keyH);
                this.keys.push(key);
                this.group.add(key.mesh);
                currentX += w + gap;
            });
            currentY -= (keyH + gap);
        });
    }

    resetStates() {
        this.keys.forEach(k => {
            if (!k.isPressed) k.setState('idle');
        });
    }

    getIntersectObjects() {
        return this.keys.map(k => k.mesh);
    }

    type(char) {
        if (char === 'DEL') {
            this.typedText = this.typedText.slice(0, -1);
        } else if (char === 'SPACE') {
            this.typedText += ' ';
        } else {
            this.typedText += char;
        }
        const el = document.getElementById('output');
        el.innerText = this.typedText || "READY TO TYPE...";
        el.style.textShadow = "0 0 15px #ffffff";
        setTimeout(() => el.style.textShadow = "0 0 5px #00ffcc", 100);
    }
}

// --- 6. CLASS: HAND TRACKING ENGINE ---
class HandTrackingEngine {
    constructor(videoElement, onResultsCallback) {
        this.video = videoElement;
        this.onResults = onResultsCallback;
        this.hands = null;
        this._initMediaPipe();
    }

    _initMediaPipe() {
        Utils.log("Initializing MediaPipe Hands...");
        this.hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.65,
            minTrackingConfidence: 0.65
        });
        this.hands.onResults(this._handleResults.bind(this));
        this._startCameraLoop();
    }

    async _startCameraLoop() {
        if (this.video.readyState >= 2) {
            await this.hands.send({image: this.video});
        }
        requestAnimationFrame(this._startCameraLoop.bind(this));
    }

    _handleResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            Utils.setStatus('st-hand', true);
            this.onResults(results.multiHandLandmarks[0]);
        } else {
            Utils.setStatus('st-hand', false);
            this.onResults(null);
        }
    }
}

// --- 7. CLASS: INPUT SYSTEM (LOGIC & PHYSICS) ---
class InputSystem {
    constructor(scene, camera, keyboard) {
        this.scene = scene;
        this.camera = camera;
        this.keyboard = keyboard;
        this.raycaster = new THREE.Raycaster();
        this.fx = new ParticleSystem(scene);
        
        this.cursorGroup = new THREE.Group();
        this.scene.add(this.cursorGroup);
        this._createCursorVisuals();

        this.smoothIndex = new THREE.Vector3();
        this.smoothThumb = new THREE.Vector3();
        this.isPinching = false;
        this.lastPinchTime = 0;
    }

    _createCursorVisuals() {
        const dotGeo = new THREE.SphereGeometry(0.06, 16, 16);
        const dotMat = new THREE.MeshBasicMaterial({ color: 0xff3333, depthTest: false });
        this.indexDot = new THREE.Mesh(dotGeo, dotMat);
        this.thumbDot = new THREE.Mesh(dotGeo, dotMat);
        
        const ringGeo = new THREE.RingGeometry(0.02, 0.04, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
        this.crosshair = new THREE.Mesh(ringGeo, ringMat);
        
        const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
        this.connector = new THREE.Line(lineGeo, lineMat);

        this.cursorGroup.add(this.indexDot, this.thumbDot, this.crosshair, this.connector);
        this.cursorGroup.visible = false;
    }

    processHand(landmarks) {
        if (!landmarks) {
            this.cursorGroup.visible = false;
            Utils.setStatus('st-pinch', false);
            return;
        }

        this.cursorGroup.visible = true;

        const rawIndex = this._projectToScene(landmarks[8]);
        const rawThumb = this._projectToScene(landmarks[4]);

        Utils.smoothVector(this.smoothIndex, rawIndex, CONFIG.INTERACTION.SMOOTHING_ALPHA);
        Utils.smoothVector(this.smoothThumb, rawThumb, CONFIG.INTERACTION.SMOOTHING_ALPHA);

        this.indexDot.position.copy(this.smoothIndex);
        this.thumbDot.position.copy(this.smoothThumb);
        this.connector.geometry.setFromPoints([this.smoothIndex, this.smoothThumb]);

        const pinchCenter = new THREE.Vector3().addVectors(this.smoothIndex, this.smoothThumb).multiplyScalar(0.5);
        this.crosshair.position.copy(pinchCenter);

        this._checkPinchLogic(landmarks[8], landmarks[4], pinchCenter);
        this.fx.update();
    }

    _projectToScene(landmark) {
        // <--- ВИПРАВЛЕНО: Інверсія координат X для дзеркального режиму
        const vector = new THREE.Vector3(
            ((1 - landmark.x) * 2) - 1, 
            -(landmark.y * 2) + 1,
            0.5
        );
        vector.unproject(this.camera);
        const dir = vector.sub(this.camera.position).normalize();
        const distance = (CONFIG.KEYBOARD.POS_Z + 2 - this.camera.position.z) / dir.z;
        return this.camera.position.clone().add(dir.multiplyScalar(distance));
    }

    _checkPinchLogic(rawIndex2D, rawThumb2D, center3D) {
        const dx = (rawIndex2D.x - rawThumb2D.x) * (window.innerWidth / window.innerHeight);
        const dy = rawIndex2D.y - rawThumb2D.y;
        const distance = Math.sqrt(dx*dx + dy*dy);

        let threshold = this.isPinching ? CONFIG.INTERACTION.PINCH_RELEASE_BUFFER : CONFIG.INTERACTION.PINCH_THRESHOLD;
        const isCurrentlyPinching = distance < threshold;

        if (isCurrentlyPinching) {
            this.crosshair.scale.setScalar(0.5);
            this.crosshair.material.color.setHex(0x00ff00);
            this.connector.material.color.setHex(0x00ff00);
            Utils.setStatus('st-pinch', true);
        } else {
            this.crosshair.scale.setScalar(1.0);
            this.crosshair.material.color.setHex(0xffff00);
            this.connector.material.color.setHex(0xffff00);
            Utils.setStatus('st-pinch', false);
        }

        this._performRaycast(center3D, isCurrentlyPinching);
        this.isPinching = isCurrentlyPinching;
    }

    _performRaycast(origin, isPinching) {
        const screenPos = origin.clone().project(this.camera);
        this.raycaster.setFromCamera(new THREE.Vector2(screenPos.x, screenPos.y), this.camera);

        const intersects = this.raycaster.intersectObjects(this.keyboard.getIntersectObjects());
        this.keyboard.resetStates();

        if (intersects.length > 0) {
            const hitObj = intersects[0].object;
            const key = hitObj.userData.keyInstance;

            if (key) {
                key.setState('hover');
                const now = Date.now();
                if (isPinching && !this.isPinching) {
                    if (now - this.lastPinchTime > CONFIG.INTERACTION.COOLDOWN_MS) {
                        this._triggerKey(key);
                        this.lastPinchTime = now;
                    }
                }
            }
        }
    }

    _triggerKey(key) {
        key.setState('press');
        this.keyboard.type(key.char);
        this.fx.spawn(key.mesh.position);
        if (navigator.vibrate) navigator.vibrate(40);
        Utils.log(`Typed: ${key.char}`);
    }
}

// --- 8. MAIN APPLICATION ---
class App {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.keyboard = null;
        this.handTracking = null;
        this.inputSystem = null;
        this.videoElement = document.getElementById('camera-feed');
        this.canvasElement = document.getElementById('ar-scene');
    }

    async init() {
        Utils.log("System Starting...");
        Utils.setStatus('st-ai', false);
        Utils.setStatus('st-cam', false);

        try {
            await this._setupCamera();
            Utils.setStatus('st-cam', true);
            this._setupGraphics();
            this.keyboard = new KeyboardManager(this.scene);
            this.inputSystem = new InputSystem(this.scene, this.camera, this.keyboard);
            this.handTracking = new HandTrackingEngine(this.videoElement, (landmarks) => {
                this.inputSystem.processHand(landmarks);
            });
            Utils.setStatus('st-ai', true);
            this._animate();
            document.getElementById('output').innerText = "READY.";
            Utils.log("Initialization Complete.");
        } catch (error) {
            Utils.log("FATAL ERROR: " + error.message);
            console.error(error);
            document.getElementById('output').innerText = "ERROR: ACCESS DENIED";
            document.getElementById('output').style.color = "red";
            Utils.setStatus('st-cam', false);
        }
    }

    async _setupCamera() {
        Utils.log("Requesting Webcam Stream...");
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'user',
                width: { ideal: CONFIG.CAMERA.WIDTH },
                height: { ideal: CONFIG.CAMERA.HEIGHT }
            },
            audio: false
        });
        this.videoElement.srcObject = stream;
        return new Promise((resolve) => {
            this.videoElement.onloadedmetadata = () => {
                this.videoElement.play();
                resolve();
            };
        });
    }

    _setupGraphics() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x050510, 0.05);
        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.z = 5;
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvasElement,
            alpha: true,
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        const dirLight = new THREE.DirectionalLight(0x00ffcc, 0.8);
        dirLight.position.set(5, 10, 7);
        this.scene.add(ambient, dirLight);
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    _animate() {
        requestAnimationFrame(this._animate.bind(this));
        this.renderer.render(this.scene, this.camera);
    }
}

window.onload = () => {
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        alert("УВАГА! Для роботи камери потрібен HTTPS або localhost.");
    }
    const app = new App();
    app.init();
};
</script>
</body>
</html>
