<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TNTU Neural Interface v4.1 [Red Cursor & Low Profile]</title>
    
    <style>
        :root {
            --primary: #00ffcc;
            --secondary: #005544;
            --alert: #ff0000;
            --bg: #050505;
            --font-ui: 'Segoe UI', system-ui, sans-serif;
            --font-code: 'Consolas', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: var(--font-ui);
            color: var(--primary);
            user-select: none;
        }

        /* --- UI LOADER --- */
        #boot-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        
        .spinner {
            width: 60px; height: 60px;
            border: 2px solid #333;
            border-top: 2px solid var(--alert); /* Red spinner */
            border-radius: 50%;
            animation: rotate 1s infinite linear;
            margin-bottom: 24px;
        }

        #btn-init {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 16px 48px;
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #btn-init:hover {
            background: rgba(0, 255, 204, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.2);
        }

        /* --- MAIN VIEWPORT --- */
        #viewport { position: relative; width: 100vw; height: 100vh; }
        
        #cam-feed {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
            filter: grayscale(0.2) contrast(1.1) brightness(0.7);
            z-index: 0;
        }
        
        #ar-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }

        /* --- HUD --- */
        #hud-layer {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 800px; z-index: 20;
            text-align: center; pointer-events: none;
        }

        .hud-panel {
            background: rgba(5, 10, 15, 0.85);
            border: 1px solid rgba(255, 0, 0, 0.3); /* Red tint border */
            backdrop-filter: blur(8px);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .label {
            font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase;
            margin-bottom: 8px; display: block;
        }

        .target-text {
            font-size: 18px; color: #fff; font-weight: 500;
            margin-bottom: 15px; display: block;
            border-bottom: 1px solid #333; padding-bottom: 10px;
        }

        .input-display {
            font-family: var(--font-code);
            font-size: 28px; color: var(--primary);
            min-height: 40px; margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .status-msg { font-size: 12px; color: #aaa; opacity: 0.8; }
        .match-success { color: #00ff00 !important; text-shadow: 0 0 20px #00ff00; }

        @keyframes rotate { 100% { transform: rotate(360deg); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="boot-screen">
        <div class="spinner"></div>
        <div style="margin-bottom: 20px; color: #555; font-family: monospace;">KERNEL v4.1 RELOADING...</div>
        <button id="btn-init">ЗАПУСТИТИ СИСТЕМУ</button>
    </div>

    <div id="viewport">
        <video id="cam-feed" playsinline muted></video>
        <canvas id="ar-overlay"></canvas>

        <div id="hud-layer">
            <div class="hud-panel">
                <span class="label">ЗАВДАННЯ</span>
                <span class="target-text">кафедра приладів і контрольно-вимірювальних систем</span>
                
                <span class="label">ВВЕДЕНИЙ ТЕКСТ</span>
                <div class="input-display" id="user-buffer">_</div>
                
                <div class="status-msg">
                    КУРСОР ЗБІЛЬШЕНО. КЛАВІАТУРУ ОПУЩЕНО.
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TNTU AR KERNEL v4.1 - "Big Red & Low"
 * ============================================================================
 */

// --- 1. CONFIGURATION ---
const CONFIG = {
    CORE: { WIDTH: 1280, HEIGHT: 720, FPS_CAP: 60 },
    FILTER: { FREQUENCY: 60, MIN_CUTOFF: 1.0, BETA: 0.007, D_CUTOFF: 1.0 },
    
    INPUT: {
        PINCH_THRESHOLD: 0.035,
        PINCH_HYSTERESIS: 0.045,
        COOLDOWN_MS: 300,
        CURSOR_SENSITIVITY: 1.1
    },

    KEYBOARD: {
        POS_Z: -6.5,
        // ОПУСКАЄМО КЛАВІАТУРУ НИЖЧЕ (По осі Y)
        // 0 - це центр екрану. Мінусове значення - вниз.
        POS_Y: -2.0, 
        SCALE: 1.1,
        SPACING: 0.08,
        PHRASE: "кафедра приладів і контрольно-вимірювальних систем"
    },

    THEME: {
        KEY_BASE: 0x001a26,
        KEY_HOVER: 0x004455,
        KEY_ACTIVE: 0x00ffcc,
        
        // ЧЕРВОНИЙ КУРСОР
        CURSOR_OPEN: 0xff0000,   // Яскраво-червоний
        CURSOR_LOCKED: 0x00ff00  // Зелений (при кліку)
    }
};

// --- 2. ADVANCED MATH (1€ Filter) ---
class LowPassFilter {
    constructor(alpha) { this.setAlpha(alpha); this.y = null; this.s = null; }
    setAlpha(alpha) { this.alpha = alpha; }
    filter(value, timestamp, alpha) {
        if (alpha) this.setAlpha(alpha);
        if (this.y === null) { this.s = value; } else { this.s = this.alpha * value + (1.0 - this.alpha) * this.s; }
        this.y = this.s; return this.y;
    }
    lastValue() { return this.y; }
}

class OneEuroFilter {
    constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
        this.freq = freq; this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff;
        this.x = new LowPassFilter(this.alpha(minCutoff));
        this.dx = new LowPassFilter(this.alpha(dCutoff));
        this.lastTime = null;
    }
    alpha(cutoff) {
        const te = 1.0 / this.freq; const tau = 1.0 / (2 * Math.PI * cutoff); return 1.0 / (1.0 + tau / te);
    }
    filter(value, timestamp) {
        if (this.lastTime && timestamp) { this.freq = 1.0 / (timestamp - this.lastTime); }
        this.lastTime = timestamp;
        const prevX = this.x.lastValue();
        const dx = (prevX === null) ? 0 : (value - prevX) * this.freq;
        const edx = this.dx.filter(dx, timestamp, this.alpha(this.dCutoff));
        const cutoff = this.minCutoff + this.beta * Math.abs(edx);
        return this.x.filter(value, timestamp, this.alpha(cutoff));
    }
}

class Vector3Filter {
    constructor(config) {
        this.fX = new OneEuroFilter(config.FREQUENCY, config.MIN_CUTOFF, config.BETA, config.D_CUTOFF);
        this.fY = new OneEuroFilter(config.FREQUENCY, config.MIN_CUTOFF, config.BETA, config.D_CUTOFF);
        this.fZ = new OneEuroFilter(config.FREQUENCY, config.MIN_CUTOFF, config.BETA, config.D_CUTOFF);
    }
    process(vec3, time) {
        return new THREE.Vector3(this.fX.filter(vec3.x, time), this.fY.filter(vec3.y, time), this.fZ.filter(vec3.z, time));
    }
}

const Utils = {
    getDistance2D: (p1, p2, aspect) => {
        const dx = (p1.x - p2.x) * aspect; const dy = p1.y - p2.y; return Math.sqrt(dx * dx + dy * dy);
    },
    projectLandmark: (lm, camera, zDepth) => {
        const sens = CONFIG.INPUT.CURSOR_SENSITIVITY;
        const ndc_x = ((1 - lm.x) * 2 - 1) * sens;
        const ndc_y = (-lm.y * 2 + 1) * sens;
        const vec = new THREE.Vector3(ndc_x, ndc_y, 0.5);
        vec.unproject(camera);
        const dir = vec.sub(camera.position).normalize();
        const distance = (zDepth + 1 - camera.position.z) / dir.z;
        return camera.position.clone().add(dir.multiplyScalar(distance));
    }
};

// --- 3. BIG RED CURSOR ---
class PrecisionCursor {
    constructor(scene) {
        this.group = new THREE.Group();
        scene.add(this.group);

        // 1. Центральна точка (ЗБІЛЬШЕНА)
        // Було 0.016 -> Стало 0.025
        const dotGeo = new THREE.SphereGeometry(0.025, 32, 32);
        this.dot = new THREE.Mesh(dotGeo, new THREE.MeshBasicMaterial({
            color: CONFIG.THEME.CURSOR_OPEN,
            depthTest: false
        }));

        // 2. Дужки (ЗБІЛЬШЕНІ)
        // Радіус збільшено з 0.040 до 0.060
        const ringGeo = new THREE.RingGeometry(0.050, 0.060, 64, 1, 0, Math.PI);
        const ringMat = new THREE.MeshBasicMaterial({
            color: CONFIG.THEME.CURSOR_OPEN,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8, // Більш видимі
            depthTest: false
        });

        this.leftBracket = new THREE.Mesh(ringGeo, ringMat.clone());
        this.leftBracket.rotation.z = Math.PI / 2;
        
        this.rightBracket = new THREE.Mesh(ringGeo, ringMat.clone());
        this.rightBracket.rotation.z = -Math.PI / 2;

        this.group.add(this.dot);
        this.group.add(this.leftBracket);
        this.group.add(this.rightBracket);
        
        this.group.visible = false;
        this.targetColor = new THREE.Color(CONFIG.THEME.CURSOR_OPEN);
    }

    updatePosition(pos) {
        this.group.visible = true;
        this.group.position.copy(pos);
    }

    updateState(pinchStrength, isLocked) {
        // Адаптація зміщення під новий розмір (0.06)
        const maxOffset = 0.06;
        const currentOffset = maxOffset * (1.0 - pinchStrength);
        
        this.leftBracket.position.x = -currentOffset;
        this.rightBracket.position.x = currentOffset;

        const targetHex = isLocked ? CONFIG.THEME.CURSOR_LOCKED : CONFIG.THEME.CURSOR_OPEN;
        this.targetColor.setHex(targetHex);
        
        this.dot.material.color.lerp(this.targetColor, 0.2);
        this.leftBracket.material.color.lerp(this.targetColor, 0.2);
        this.rightBracket.material.color.lerp(this.targetColor, 0.2);
        
        if (isLocked) {
             this.leftBracket.position.x = 0;
             this.rightBracket.position.x = 0;
        }
    }

    hide() { this.group.visible = false; }
}

// --- 4. KEYBOARD ---
class Key3D {
    constructor(char, x, y, w, h) {
        this.char = char;
        this.container = new THREE.Group();
        this.container.position.set(x, y, 0);

        const geometry = new THREE.BoxGeometry(w, h, 0.04);
        this.material = new THREE.MeshPhongMaterial({
            color: CONFIG.THEME.KEY_BASE, transparent: true, opacity: 0.9, shininess: 60
        });
        
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.userData = { keyInstance: this };

        const edges = new THREE.EdgesGeometry(geometry);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00aa88, opacity: 0.3, transparent: true });
        this.outline = new THREE.LineSegments(edges, lineMat);

        this.label = this.createLabel(char, w, h);

        this.container.add(this.mesh);
        this.container.add(this.outline);
        this.container.add(this.label);
    }

    createLabel(char, w, h) {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 256, 256);
        ctx.fillStyle = '#ffffff';
        const fontSize = (char.length > 1) ? 80 : 140;
        ctx.font = `600 ${fontSize}px "Segoe UI", sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        let display = char;
        if (char === 'SPACE') display = '␣';
        ctx.fillText(display, 128, 128);
        const texture = new THREE.CanvasTexture(canvas); texture.minFilter = THREE.LinearFilter;
        const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const geo = new THREE.PlaneGeometry(w * 0.9, h * 0.9);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.z = 0.051;
        return mesh;
    }

    setState(state) {
        switch (state) {
            case 'active':
                this.material.color.setHex(CONFIG.THEME.KEY_ACTIVE);
                this.mesh.scale.z = 0.5; break;
            case 'hover':
                this.material.color.setHex(CONFIG.THEME.KEY_HOVER);
                this.mesh.scale.z = 1.0; break;
            default:
                this.material.color.setHex(CONFIG.THEME.KEY_BASE);
                this.mesh.scale.z = 1.0;
        }
    }
}

class KeyboardSystem {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.keys = [];
        this.textBuffer = "";
        
        this.generateLayout();
        
        // Позиціонування: Z (глибина) + Y (висота)
        this.group.position.set(0, CONFIG.KEYBOARD.POS_Y, CONFIG.KEYBOARD.POS_Z);
        this.group.scale.setScalar(CONFIG.KEYBOARD.SCALE);
        this.scene.add(this.group);
    }

    generateLayout() {
        const rows = [
            ['Й','У','К','Е','Н','Г','Ш','Щ','З','Х'], 
            ['Ф','І','В','А','П','Р','О','Л','Д','Ж'], 
            ['Я','Ч','С','М','И','Т','Ь','Б','Ю'],    
            ['Ц','Ї','Є','-','SPACE','⌫']
        ];

        const kW = 0.5; const kH = 0.5; const gap = CONFIG.KEYBOARD.SPACING;
        let cY = 0;

        rows.forEach(row => {
            let rowWidth = 0;
            row.forEach(c => {
                let w = kW; if (c === 'SPACE') w = 2.0; if (c === '⌫') w = 1.0;
                rowWidth += w + gap;
            });
            rowWidth -= gap;
            let cX = -rowWidth / 2;

            row.forEach(char => {
                let w = kW; if (char === 'SPACE') w = 2.0; if (char === '⌫') w = 1.0;
                const centerX = cX + w / 2;
                const key = new Key3D(char, centerX, cY, w, kH);
                this.keys.push(key);
                this.group.add(key.container);
                cX += w + gap;
            });
            cY -= (kH + gap);
        });
    }

    resetKeys() { this.keys.forEach(k => k.setState('idle')); }
    getColliders() { return this.keys.map(k => k.mesh); }

    handleInput(char) {
        if (char === '⌫') { this.textBuffer = this.textBuffer.slice(0, -1); }
        else if (char === 'SPACE') { this.textBuffer += ' '; }
        else { this.textBuffer += char.toLowerCase(); }
        this.updateUI();
    }

    updateUI() {
        const el = document.getElementById('user-buffer');
        el.innerText = this.textBuffer + "_";
        if (this.textBuffer.trim() === CONFIG.KEYBOARD.PHRASE) {
            el.classList.add('match-success'); el.innerHTML = this.textBuffer + " ✅";
        } else { el.classList.remove('match-success'); }
    }
}

// --- 5. ENGINE ---
class Engine {
    constructor() {
        this.video = document.getElementById('cam-feed');
        this.canvas = document.getElementById('ar-overlay');
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.z = 5;
        
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const ambi = new THREE.AmbientLight(0xffffff, 0.65);
        const dir = new THREE.DirectionalLight(0x00ffcc, 0.7);
        dir.position.set(0, 10, 5);
        this.scene.add(ambi, dir);

        this.keyboard = new KeyboardSystem(this.scene);
        this.cursor = new PrecisionCursor(this.scene);
        this.raycaster = new THREE.Raycaster();

        this.filterIndex = new Vector3Filter(CONFIG.FILTER);
        this.filterThumb = new Vector3Filter(CONFIG.FILTER);
        
        this.isPinching = false;
        this.lastClickTime = 0;

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    start() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(this.onHandResults.bind(this));

        const camera = new Camera(this.video, {
            onFrame: async () => await hands.send({image: this.video}),
            width: CONFIG.CORE.WIDTH, height: CONFIG.CORE.HEIGHT
        });
        camera.start();
        this.animate();
    }

    onHandResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            this.cursor.hide(); return;
        }

        const landmarks = results.multiHandLandmarks[0];
        const now = performance.now() / 1000;

        const rawIndex = Utils.projectLandmark(landmarks[8], this.camera, CONFIG.KEYBOARD.POS_Z + 1);
        const rawThumb = Utils.projectLandmark(landmarks[4], this.camera, CONFIG.KEYBOARD.POS_Z + 1);

        const smoothIndex = this.filterIndex.process(rawIndex, now);
        const smoothThumb = this.filterThumb.process(rawThumb, now);

        const centerPos = new THREE.Vector3().addVectors(smoothIndex, smoothThumb).multiplyScalar(0.5);
        this.cursor.updatePosition(centerPos);

        const aspect = window.innerWidth / window.innerHeight;
        const dist2D = Utils.getDistance2D(landmarks[8], landmarks[4], aspect);
        const pinchStrength = 1.0 - Math.min(Math.max((dist2D - 0.02) / (0.08 - 0.02), 0), 1);
        const threshold = this.isPinching ? CONFIG.INPUT.PINCH_HYSTERESIS : CONFIG.INPUT.PINCH_THRESHOLD;
        const isClosed = dist2D < threshold;

        this.cursor.updateState(pinchStrength, isClosed);
        this.processInteraction(centerPos, isClosed);
        this.isPinching = isClosed;
    }

    processInteraction(cursorPos, isClosedNow) {
        const screenPos = cursorPos.clone().project(this.camera);
        this.raycaster.setFromCamera(new THREE.Vector2(screenPos.x, screenPos.y), this.camera);
        const intersects = this.raycaster.intersectObjects(this.keyboard.getColliders());
        this.keyboard.resetKeys();

        if (intersects.length > 0) {
            const key = intersects[0].object.userData.keyInstance;
            if (key) {
                const now = Date.now();
                if (isClosedNow && !this.isPinching && (now - this.lastClickTime > CONFIG.INPUT.COOLDOWN_MS)) {
                    key.setState('active');
                    this.keyboard.handleInput(key.char);
                    this.lastClickTime = now;
                    if (navigator.vibrate) navigator.vibrate(25);
                } else if (isClosedNow) {
                    key.setState('active');
                } else {
                    key.setState('hover');
                }
            }
        }
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));
        this.renderer.render(this.scene, this.camera);
    }
}

document.getElementById('btn-init').addEventListener('click', () => {
    document.getElementById('boot-screen').style.opacity = '0';
    setTimeout(() => {
        document.getElementById('boot-screen').style.display = 'none';
        const engine = new Engine();
        engine.start();
    }, 500);
});

</script>
</body>
</html>
